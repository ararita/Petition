foreign keys:
id |    name     | singer_id
----+-------------+-----------
 1 | Anaconda    |         1
 2 | Paparazzi   |         2
 3 | Bad Romance |         2
 4 | Sex Bomb    |         4

 id |     name
----+--------------
  1 | Nicki Minaj
  2 | Lady Gaga
  3 | Taylor Swift
  4 | Tom Jones

SELECT songs.*, singers.name
FROM songs
JOIN singers
ON singers.id = songs.singer_id;


SELECT singers.name AS singer_name, songs.name AS song_name
FROM singers
JOIN songs
ON singers.id = songs.singer_id;

singer_name |  song_name
-------------+-------------
Nicki Minaj | Anaconda
Lady Gaga   | Bad Romance
Lady Gaga   | Paparazzi
Tom Jones   | Sex Bomb


LEFT JOIN ce nam dat sve iz obje tablice, ujedno i one vrijednosti koje nemaju sta joinat, dok ce nam samo JOIN dat samo one koje imaju svoj par (npr ako imamo song koja nema izvodaca za joinat, konacna tablica ce izostavit taj song, dok ce ga left join ili FULL JOIN ukljucit)


join for the purpose of getting data out, join se ne moze koristit za npr dodavanje ili updateanje dvaju tablica odjednom.



vazno je AS kao u: SELECT singers.name AS singer_name, songs.name AS song_name, jer cemo inace imat rezultat sa dva name colons. znaci da ce jedan overwritat drugog. zato on, u ovom slucaju cemo umjesto name dobit singer_name kao colon





after registering, send the to 'profile', we need age, city, homepage. button continue. but user can skip it.
user can only get here immediately after registration. if they wanna log in later, they don't see it anymore.

when they click continue they should be in the petition.

trebamo user_profiles sql.
DROP TABLE IF EXISTS user_profiles;

CREATE TABLE user_profiles(
id SERIAL PRIMARY KEY,
age INT,
city VARCHAR(100),
url VARCHAR (400),
user_id INT REFERENCES users(id) NOT NULL

);

this is optional(age etc..) so if user fills them, send to database.

we wanna use that data on the signers page. we wanna show it if its available. if they gave a homepage, we want to be able to click it

in signers page:
{{#signers}}
{{#if url }}
<a href="{{url}}">{{first}} {{last}}</a>
{{else}}
{{first}} {{last}}
{{/if }} {{age}} <a href="/signers/{{city}}">{{.}}</a>{{/city}}
{{/signers}}


we need JOIN but we don't need first and last in signatures.sql, cause we have it in users.sql
signature, user id only stay in signatures.sql, so remove it from the db.querry addSignature (?)


city link(if they have it)-->
app.get("/signers/:city", (req, res) => {
const city = req.params.city;
}

getSigners
we need another route and another query: with the WHERE clause

WHERE LOWER(city) = LOWER($1); --ovo da izbjegnemo velika i mala slova kao issue


security issue: pitaj nekog kako


3 new routes
get post




part5:
adding edit profile homepage when user goes to edit page, some input fields should be already there, except password.

get route:
new hanldebars template, <form> tag: input foleds and a button (input filed for every single category (7 inputs -first, last, email, password, age, city, homepage; plus the 8th hidden csrf))

we need data base to get the ones that are prepopulated: but they're in two tables, zato trebamo JOIN query


post request:

what to do when user clicks update button:

inside of req.body, we will have all of the infos feom all of the fields and the value of them.

so in server, we need ot handle 2 situations:
1. what to do if user DOES provide a new password
2. what if DOESN'T

so post might look like this:

app.post('/edit', (req, res) => {
if(did user enter a new password?

Promise.all(we pass here both of the queries, and when theyre done, then block will give us results).then(then will not run, until queries are done))
} else (

))



if new password ---> 2 querries:

1. its going to update the 'users' table, and updates 4 columns (first, last, email, password) - we're updating all of them even if user didnt change them;


2. querry - will update user_profiles, will handle the last 3 input fileds.
-we dont know if user has the row (do we run on INSERT or an UPDATE):
so we can write a query that will check insert if theres a row, and insert if no, and if yes, it will update ---> so we use UPSERT query


PASSWORD FIELD MUST STAY EMPTY! because every field gets updated, and


if user DOESN'T ENTER A NEW PASSWORD:

we need 2 queries:

1. first query will update users, and inside will update 3 columns - first, last, email
2. query should also be UPSERT


what we do when updates happen and work, its up to us where we wanna redirect the user



UPDATE AND UPSERT:



-----update
UPDATE nameOfTable
SET nameOfColumn = $1,
    nameOfColumn2 = $2 (we can update as much columns we need)
WHERE id = $4 (specifies which row we wanna update)



-----upsert:
INSERT INTO nameOfTable (nameOfColumn, nameOfColumn2)
VALUES ($1, $2, $3)
ON CONFLICT (nameOfColumn)
DO UPDATE SET nameOfColumn2 = $2


example:
INSERT INTO actors (name, age, oscars)
VALUES ('PenÃ©lope Cruz', 43, 1)
ON CONFLICT (name) ----> name is the column that might give us an error, cause it already exists
DO UPDATE SET age = 43, oscars = 1;




DELETE YOUR SIGNATURE:


on /thanks page:
thats a button, looks like a link , but its a button inside of the form tag (you can use css to make it look like a link)-and we need a POST request

so---> in server



delete query:
DELETE FROM nameOfTable WHERE id = $1 (when the query runs, the $ will be replaced with users id, npr 4);
